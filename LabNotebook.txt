For The Night is Dark and Full of Bugs

The Log Before Time:
  Notes:
  Cross seems to be functioning strangely because it subtracts with tuples. I added 
  numpy to do that instead and it seems to be working. Will examine how it compares to Fortran after.
  
  Changed planehit. It was saying 3 was out of bounds for axis 0 with size 3
  
  The print statements (including what is commented out):
  
  Was previously having troubles reading nbox.
      Found it was an undefined list, set it to an empty list. Still had errors
      Resolved by setting it to list with points [0,0,0] 
  ****Technically it works in that it reads through, but is no doubt causing errors. Will return later

  We defined something wrong, probably many things 
      Problem: A lot of the Parameter file was different, resulted in 400 rays total
      Solution: Copied data wholesale from .f file and now yspace and zspace is consistent to 6 decimal places.

  boomarray is just long list of empty zeros

  Veci starts out with different rounding and by the time it is used in 
    function the value reads as "nan", this may be what is causing everything to return 0s

  Successfully limited 'F' and 'r' to 8 digits!
    Still getting overflow issues, may have to do that for each individual variable :c 

  Found the diversion, but diversion is at boomarray.

  Finally matched boomarray outputs
      But Fortran seems to assign first up to Raymax,then goes to the next one. Python may or may not be working that way. It seems to be formatting differently
      Ex 
        Fortran  123456789...Raymax 12345...
        Python   111 222 333 444 555 666 777...Raymax,Raymax,Raymax
    In theory it shouldn't matter, they both find values from specified coordinates.
      We'll see.
        It's the same, no bugs here 10/2/18

        Added 1's and parentheses to xmin == xmax. Remember to do that for others in initialgrid.

  Looked at n2, this looks like a familiar glitch

  vecip1 is all nan, I remember this.
  boxarraynear and boxarrayfar were giving syntax errors, but they seem to be working, regardless.

  veci and np.array(F) are nan 
    veci is nan from it's first definition



  What I /think/ I was originally doing:
      Says error encountered with true_divide for nbox, it is dividing by zero. 
      The first should be -1.000, and then the rabbithole happened

  Changed np.array(F) to just F and it spit out so much good data
        It crashed immediately after, but that's still good enough
        It gave proper results for nbox and others
        It also started giving me a reading for normal

    May have Successfully validated vecip1  up to "Check intersection with Boxes"
        Only needed to use numpy multiply
  onwards to line 470!

  It's actually running.
  I'm just going to leave it running to see if it crashes at the end now 

  Bug spotted in spherecheck
      Had to use RPS for receriver array, try checking if I can import it once and be done with it
        I didn't like that solution. I'd have to copy RPS for everything from that file. I used from import instead.
        Receiverpoint is defined weird in python 
          threw in a placeholder
          fixed when parameterfile was looked at

  New crash:     Vinitial=np.around([boomarray[ray,0],boomarray[ray,1],boomarray[ray,2]],8)
  The note means it is a known bug 
        used ray-1 and it got to "timeconstruct has been called"

  Headers
    write statements work when paste into powershell :c 
        I forget what I did, but it works now. (The next day)
    Slight differences in how it is displaying. This may or may not cause problems with matlab
      but that's a problem for the future me. 

  Next is finally finding where the memory is going 
      yay :/

      Did we remember to deallocate all those arrays we used zeros for?
        Is it even necessary for everything?

        finding a hit is really slow
          we seem to be importing a lot
            Moved all imports in Functions.py to the main 
              I think it's going faster, but I also still don't have concrete numbers
        spherecheck works
        I still think it's redoing something heavy

      Veci and others were defined as lists, redefined them as arrays
      f.write was only printing as ints and the input was small 0.somethings, fixed it.
    What is the difference between using np.zeros and np.array?
      Test afterwards

    alphanothing was defined as an array of [0.0] 
      I'm pretty sure it's not supposed to be that
        we defined sizeffttwo AFTER something that references it.
          When I went to move that thing I saw we defined alphanothing right once and then redefined it as [0.0] for some reason
            This happens twice. It might of been a patch then, maybe not 

        fixed ampinitial and ampfinal 
          it runs slower now
        Idea: It may be all the arrays slowing it down 
          tried using empty instead of zeros, no noticable difference

      There were two more arrays we did not define. Luckily I was able to test out np.empty c:

      Looking at bugs in receiverhitfunc
        We need to use numpy to multiply the complex of the absolute value of two arrays.
          There were a lot of words used and they sound like they may be prone to bugs and eating memory
        Case in point: I was ACTUALLY supposed to take the complex of the product of two absolute values
          Oops

        Find how XJ behaves
            It was a tuple instead of a complex
          Supposed to multiply by 1199 (temparray[D,W,5]), but it's 0 instead
          I checked where it was defined. We used 0.0 in both, the question is why is it not 0 in Fortran

          I think using e to the power of the complex would solve the error but
            1. The input is bugged anyway and I can't get what it to run the test
            2. That's only if I understand what it's doing right 

            Remeber to allocate all arrays 
              (np.empty may reduce the need to allocate and deallocate the arrays)

AFTER A FOUR HOUR RUNTIME :
C:\Users\Kory George\AppData\Local\Programs\Python\Python37\python.exe: Error while finding module specification for 'RayTrace.py' (ModuleNotFoundError: __path__ attribute not found on 'RayTrace' while trying to find 'RayTrace.py')

      Find an I vector -DR 10/23/18
      
Trying to get pypy working -10/30/18
  No experience with this, had to make symlink doig something with pypy
    Made link in pytest folder, it still didn't work. Make pypy link in ray folder. Let's see what happens
    It didn't work :/

    Home, Later 
      can pypy run on conda?
      Answer: Maybe, I didn't get a chance to try it  (11/5)

    In the office it was not giving any outputs when running pypy on powershell.
    But I tried today (11/5) and it worked perfectly. Going to put finding an alternate route on hold for now.
    We'll see later when I hit my next error. 
    Going to continue trying to get numpy installed on pypy for powershell now   


#For future refernce: 
#  What works
#  Steps to get pypy working with numpy 
#     C:\pypy3-v6.0.0-win32\pypy3.exe -m ensurepip (installing pip)
#     C:\pypy3-v6.0.0-win32\bin\pip3.5 -U pip wheel (upgrading pip with wheel)
#     

  What didn't work
    C:\pypy3-v6.0.0-win32\bin\pip3.5 install numpy
    C:\pypy3-v6.0.0-win32\bin\pip3.5 --upgrade setuptools 

  What may or may not have worked, I'm not sure 
    C:\pypy3-v6.0.0-win32\bin\pip3.5 install numpy
      It "worked" after upgrading with wheel, it did more things and got more error messages.
      A lot of error messages in fact.
    Installing pygments worked perfectly. It should. It was the example install.
      But doing that helped with nothing related to numpy
    I got it to successfully install numpy by brute forcing powershell, but not in the right directory
      Just going to brute force it (After midnight, so technically 11/6)

###I won't be deleting what I've written before, but ignore all of it.
I just cd'd into 
    C:\Python27\Lib\site-packages
and downloaded numpy the brute force way with
    git clone https://bitbucket.org/pypy/numpy.git
It looks like it works
*10 seconds later*
It didn't. 
Went digging online. The numpy that I literally just installed might be out of date 
Went checking using pypy. Numpy has no defined attributes at all

Retry the next day: 
  Installing VS 2017 @ https://visualstudio.microsoft.com/downloads/


Pypy was messy, going back to py3 to avoid another rabbit hole  11/6

Going back to optimization by breaking down to more functions
    Tried turning the comments into function descriptions. It works on individual tests, but not for the functions we already have

  Function descriptions work now for some reason. Added descriptions of what each function is and does 
  this should save time now. Hopefully -11/9 

The functions and raytrace files Will was working on were older versions. 
Going to just change my loops to for loops instead of looking back over my changes

******Note: Find what needs to be an int in the code, because // just leaves a rounded off float
  Some things don't mind. Others do

Found how to calculate times -11/10
    using time module use time.time() to set a variable to start of interval
    Then print time.time() -t to find the difference 

    Found the time on our functions are negligible. Nothing greater than 10^-3 seconds. 
      Some close but not a single one over 

    Isolated checks with powershell show that putting loops in functions speeds them up 
      But when I tried it with Absorption there was no notable difference ¯\_(ツ)_/¯

In receiverarray we have 4 outputs. I think we can cut down on that if we use methods and classes
    [The Next day, 11/11]: We totally can

Played around with using methods, functions, and putting code in main. tl;dr from method_fill.py

 Method was slower than using a function in all tests.
 But I'm biased towards using Methods because I just spent a day learning them. 
 Both options are noticably better than having the code outside any functions at all

  Looked at Will's methods. Took the time and it varies from the same runtime, to 8x faster,
    to infinitely faster (it was too small to measure) 11/15/18
 
  Still experimenting with methods. I found we can define basic python functions (print,+,etc)
    with them and change how they work. That may remove the need for some of Functions.py 
        (Remeber to actually test tho)

*        Things I /think/ we can redo: 
*          fun.dot
*          fun.cross
*          Make Receivers into instance methods instead of hardcoding them 
*            (My understanding of what Will did. The thing that runs infinitely faster)

    Tried to define receivers using methods instead. It seemingly works flawlessy.  11/17/18
      It also takes a half of a percent of the time of the previous method. (In hindsight it probably wasn't that fast, but it sounds nice -6 hours later)
      We should probably use methods more often.

#    Things I have learned/heard on the internet to try:
#TBD      Jupyter Notebook for pypy (Alternatively: "Get a new computer" was suggested)
#
#TBD      Make a kernel in C which controls the rest of the file still in python 
#        (C is a lower level program, therefore faster, and still works with python)
#(Sounds hard though)
#
#      Use methods and functions (Working out so far)
#(Works great)

Looked at other receivers in the Fortran file. ReceiverGround.f looks promising

Grid is useful. It is only useful for complex receivers (Like that one ^)
  I'm moving it into the receiver file to use for the receiver file

Note for future reference:
  Instead of one central file which does all the work (which is bad for python), we're decentralizing it, making multiple modules that individually run the calculations
  Writing because I'm pretty sure I'll fall into another rabbit hole and make one gigantic file by accident

Captain's log, Star Date: 11/21/2018
  Previously I had made individual arrays at specific positions, then read them into receiverarray. This made receiverarray into a copy of the positions
    meaning after it was created, receiverarray had little to no interaction with the receivers.
    I have just figured out how to define a list of the specific receivers, able to open, interact, and edit their properties on command. 
      This is great news (to me) I won't be able to test how it actually works until we have something to hit the receiver, but it "works" 

The main body of ray trace seems to be one loop nested inside another with minor changes  -11/27

Putting part of raytrace in a function to test (sizefft_scrap.py)
  lastreceiver and lastreceiver2 are two separate receivers, only lastreceiver is ever changed
  This does not affect my test, I'm leaving it as is 

Hello Bug Log my old friend, I've come to talk with you again -12/5
  I found that python handles lists and arrays much better than it handles scalars (ints)
    Example: Found that someone sped up their Python by using a list of the x positions and y positions instead of using for-loops 

12/13
  I was trying to do operate on the arrays as matrices instead of for-loops. Targeting specific
  columns in python is messy without using another library. I decided to divide some of our arrays
  inputarray[:,0] is now frequencies  (ft a spelling mistake that I want to see if anybody corrects)

Why does outputsignal need exactly one more point than half K? -12/13
  If I change this, will it crash the code, make it innacurate, or do nothing? 
    (Next mention, 12/24 : outputsignal)
Hilariously we have both twopidx and twopi*dx. I have to check if those are the same values or 
coincidentally named that way 
    Yes. But only sometimes. Other times twopidx is twopi *dxground

12/21 
  Finished finals, moving back to this
  Here's a handy dandy runthrough on how to use np.where, since this is my third time not knowing. It's going to come up a fourth
  np.where(condition,target_array,directions)
    a) condition is just like using an if loop
    b) target_array is just which array to modify. You could modify the array that fulfils these conditions, 
        or target an array and for each position where the condition is fulfilled it will do the select operation 
    c) directions are where the fun happens. You could set the position equal to a value. I cannot put into words how flexible that definition is
        You could use it to work on the array you're checking, or you could replace it with another array, or even insert a value from a separate operation entirely

12/24
  I'm not sure if I've written this yet, but my terminal has been pink for the longest time now.
  It may or may not be related to getting vscode to actually run the folders.
  The pink is illegible, I had to switch to cmd to see what I'm doing
  In a related vein, now that I can see these; whew do we have a lot of undefined variables in functions.
  I think we haven't noticed because we don't use some of these functions in our 
  current model

  create_init_signal: 

    Specifying a specific column in python is kind of tedious. There is probably a way 
    to do it. I know there is a module, but I'd like to cut down on extra modules, so 
    I'll be breaking down inputarray into its components.

    I've been meaning to get rid of inputarray for a while now. Here are the notes
      [K,0] is listed as frequencies whnn first defined. I thought I'd have to call it something different
        No. I don't further down the code, it seems to be described as the initial pressures.
        After that, this column is unused. I'm making a judgement call and renaming it pressures

        *** This is also temparray[D,W,3]
      [K,1]
        ???
      [K,2] 
        ??? but linked to the last ??? so only one ???, see below.
        (I got sidetracked with more stuff and never came back to this)

    I have it create the local arrays then set those as the values of the global because
     when I was doing the time tests with python before it seemed that accessing a global 
     from a class was slightly slower than a local. 
     Therefore instead of accessing it 18000 times I work on the local then set it once.

    comments on outputsignal:
      1. We start by defining it as K/2+1 (sizeffttwo, but we haven't defined it yet) 
      2. We then set it equal to the fast fourier transform of inputsignal with length of sizefft(*) 
        a) I looked over the documentation in numpy, if it's sizefft then half our graph should be 
            zeros if not for:
        b) fft.fft returns an array already. We don't need to define one beforehand 
          I think these two bugs cancel each other out. I love it 
        c) according to the documentation, if you run fft.ftt with an odd number then it
            kneecaps your speed. 
      I still don't know why we're using 9001 and it seems like it hasn't caused any bugs
       because it's canceled out by other bugs. It exists in Fortran, but that may be a 
       Fortran specific reason. I am going to risk breaking everything, and just make it 9000

      I checked and it looks like it should be given sizefft. That change is in my scrap paper, not the original (yet)

      Since we're now using array math instead of defining things individually, we can work on airabsorb.
        airabsorb is defined using Absorption. This is (seemingly) the only time that function is used.

        I see a note I left that absorption doesn't take much time. Before I checked the time 
         inside the function. This was minimal. This function runs 18k times with other functions.
         whoops

        We define hr three seperate times in this function.
          First in the parameter file
          Second in the call
          Finally we initialize the same value as the parameterfile
        
        I got the Absorption function to work with  the file. It didn't /need/ any adjustments
         python treats all arrays as their datatypes. So in theory I didn't have to do anything

        I'm also just realizing that everything in inputarray is defined using sizeffttwo
        Need to check if half the inputs are 0 and if that's soemthing we want to happen 

  To avoid that lag I get when I open the file and forget what I need to do:
  1. ^That
  2. Find the time it takes to define the section I just did, as it already exists and how I modified it
    a) It takes place in pieces 
    b) it takes place inside of other operations 

  3. Validate. 
  4. Extract similar functions from the main and repeat 2 and with them 
  5. Other stuff, this list is starting to look long and intimidating. 

  Last thought of the night:
  (Check)  Of the arrays I worked on today, inputarray[:,0] is the only sequential one. It 
     can be taken out of the for loops using np.arange(1,sizefft+1)   
     The rest of the array can be defined using simple arraymath like I did with airabsorb
    ***Keeping in mind that I'm going to compartmentalize them, this seems like the best course.

12/26
    Both inputarray[K,0] and inputarray[K,1] seem to be frequencies. Because I need to have them
     seperately listed but not confusing I will make the second one Spanish. Also I'm numbering them.

    Sizefft Arraymath:
      Made first column using an arange. Results are consistent but the old version stops at 9000 
       even though it is defined until 18000, the new version continues past there. I vaguely remember 
       thinking a similar glitch would happen earlier. But I cannot rememeber why now
      
      Left it as sizefft because that's the size of the array in fortan, if it's too long then we 
        can cut it down in a single line of code

        The answer to why they're all 0 after 9000: The loop is supposed to go to sizeffttwo, not sizefft (y tho)
      
      The other arrays were broken down into their individual values. The numbers are consistent. 

      After more testing it looks like they were originally sizeffttwo to match airabsorb

  Results of 12/26/18: 
    1. Created inputarrays with matching values that can all be used individually.
    2. Arraymath is 100x faster than loops. 
        I took the first 5 measures by themselves, then opened a program after to measure the times.
         The array math would be more noticably affected by the background program. The loops were already pretty slow.
    3. It would be difficult to measure how much time the Fortran process takes for only that, but we need to find something

12/27
      Theoretical work:
        I was looking into how we define arrays. I can see one problem going forward. For position we have 3 places each. 
         When we get a hit it needs to output only one column. We can definitely solve this with a function, but it'll 
         be a messy function
      Work work: 
        Examined a few variables. We only use vinitial,finitial and tmp once outside main. They also have the same name.
         This is confusing for me to look at, I'm going to looks at a way to reword this.

         I can add some math to the bottom of the parameterfile. In the final version it will be a separate file that converts 
          the parameterfile into a more workable format. Right now it's just some extra math at the bottom.

        It looks like we define length several times through the code and don't use it until the very end.
        We don't define xspace, either in the parameterfile or raytrace. In Fortran we initialize it then never touch it again
         I don't know what to do about that, I'm just keeping a note of it 

        I can define all the information in initialgrid as an array, but it'll be on its side. I CAN flip it, but then it's in reverse.
        Fixed the reverse issue. I actually don't know why these need to be paired together, but That's a problem for future me.
        I get a glitch where the dimensions don't match (it doesn't know how to treat 73 and 25)
          I now see that this is a gradient/mesh 

        That's information for later, I'm late here, in this current moment. 

        Results: Found that only works if xmin == xmax, otherwise it will all crash.
                 Defined boomarray without for-loops. 

12/27 Again
          I came back home and I've been thinking a lot about this
          Remember when I said I needed to get another module to do quick array math? Yes, well that would help, but I realized if I 
           play with : just right I can avoid all of that. 

          I'm trying that method and the boundaries we use use for outputsignal (sizefft) are bigger than the second row of inputarray(sizeffttwo)
           That's causing an error

           Successfully made the initializer into a function. Just as our previous research showed, it was faster than usual. 
           Fastest recorded runtime was 1.03 thousandths of a second. Which is not a lot compared to yesterday, but it was 0.2 seconds before that

           Do We ever actually use alphanothing?

          I found the original problem that made me want to use several single arrays. 
           Using a 3 dimensional array(temparray) in relation to a 2 dimensional one(receiverarray)

12/28
        What if instead of the 3 dimensional array which has been a terror to work with, I added 5 two dimensional 
         arrays to each receiver?
          That seems to initialize. I don't know if it works yet tho 

        It seems that the receiverlist is unable to be operated on by loops
            I was wrong. It just took some manipulating
        
        Replaced temparray with individual array of values on each array

        It seems like allocating absorbtion coefficients can be done with a where condition
            It can't. Or I wasn't doing it properly. 

        I decided to just power through since it's already a fraction of a second.
        The final time for the first third is 70 miliseconds. Fast, but slow compared to the gains 
         from before. 
      Good enough for now. 

1/1/
    I sure am glad I don't have to work more than a year on this. The dates would get confusing otherwise
                 
    I tried to get the first third to work faster again and I decided to do the rest of it (again)
    Went thru the main function and broke it down to a few notes to hit. It looks like these can be broken into functions
      (Some of these functions will also get replaced when we move to meshes  but here we go )
    The list:
      1. Making small steps along the ray path.  For each step we should return, location, phase and amplitude
      2. Find the closest sphere and store that as the distance
      3. Check Intersection with ground plane
      4. Check intersection with building
      5. Check intersection with Boxes
      6. Check intersection with Triangles
      7. Check intersection with Squares 
      8. Check to see if ray hits within step size  (Biggest)

    I finally found what "where the code diverges" means. To avoid turning this into a long rant on one bug that got solved 
     as a background thing: It's pretty much just the Nuclear Gandhi bug running around in our code. 
    I patched it out using array math. Then I spent a few days (wrongly) trying to get it to work like in the first python 
     version. 

    I'm not sure if not breaking something counts as progress. But I'll count it anyway.
    Anyway, at the end of our main trace function we deallocate all the arrays. 
     Needless to say, this is done automatically when we put it in an array and we don't have to specify that 

    The way we initially defined veci and/or vinitial works kind of wonky when I stretch it out.
     All the data is right, it's just horizontal instead of vertical. We should flip either this or the other 

1/6
      I haven't written anything, but I've been working on the same thing for a few days.
      The particular thing is the spherecheck function. Comparing the Fortran version to now
        Fortran: It checks whether a ray hit the sphere and where if it does.
        MyPy: It checks whether all the rays hits a specific receiver. Needs to loop for each receiver.

1/6 (But in Normal People Hours)
      Still working on spherecheck. A bug in the new version is that it checks multiple arrays at once.
      This may or may not be possible. I truly do not know. But what is certain is that it causes errors 
       and I don't know how to do it without a crash. So I'm manipulating the numbers. 
       The error: It was asking for (tca - (t2hc**(1/2). The algebra for this is hopefully right. I copied it
       from our code. The problem is that it seems like all t2hc values are negative. This returns NaN and junks the function.

       I'm pretty sure this is the cause of that bug that I was looking at all those months ago.

       Evalutating ray 607 (F) for more information of problem
        All my inputs for spherecheck are off

        All of my new tca values are the tca of one ray copied many times, then the next column is the next array doing the same

        This is because the dot product is used differently than in the other function. I need to make a new dot product function 
         for this specific situation.


Note: In my new version I tear all the rays into pieces and then make changes each step. 
  When I ask the computer for an output in my new version it gives the first step of each individual ray.
  In Fortran when you ask for output it will give you each sequentialstep of the first array then move to the second.
   This does not mean you're wrong. It's just intimidating and frustrating. Just put a loop into Fortran to jump to 
   the last 3 rays at a certain point so that you can compare values. 


   I thought about it and my l2oc values are correct, but disordered.

  The reason I have been checking this function is that at a known hit (ray 606), my new array seemed to fail to register anything.
   After a day of investigation I've found that while the other methods revealed that while this ray made contact, it did not make 
   contact within a range that would show on my array. My array only shows the first step of each ray. 
   The ray did not hit in the first step. (duh) 

   This is one of those days where I spend a lot of time not tangibly doing anything, but count it as doing something.
   Anyway the distance from all the rays on the first step to anything is HUGE

   I can translate the old if conditions into my new version using np.where and np.all 
   Pros 
        Can translate well into single array (I figured it out)

   Cons 
        Does not translate well into multi arrays
        Some of our if loops are nested. Since we want the rays to act independently this'll get super messy

(10 minutes later)
    np.all has the ability to output directly to an existing array if the array has matching dimensions   


1/7
    Through all function outputs only 1d array I was able to mkae it have the needed dimensions by appending it to itself until a suitable size
    The nested loop is still a problem

    ***Idea***
      Make receiverhit into an array of raysize stored in each receiver. Change the conditional statements for that to where conditions.
        Have where-if be a function of the nested loop; where else be the same as input

        Minor testing shows that if none of the indices are true the function will not pass. This saves a lot of comp time 

      This seems like a great way to tackle all the nested loops so far, if messy 

1/11
    Testing: 1d Arrays only start to take noticable comp time (1 milisecond) when sized 2^16
              It takes 33 seconds when sized 2^32 (Max integer in python)

              2/20/19 - This gets completely thrown out the window when the size is input directly into the boom spacing


2/20
    Fell down a rabbit hole with ray interactions. The three of us are breaking it up into ground, receiver, and building geometry interactions.
      I'm doing receiver interactions (which spills over into output) so that's what I'll be writing about.


2/24 
    Even though alphanothing doesn't seem to be used I'm bringing it back in just to have something to work with to get the receivers working
      Remember to ask what specifically it does

    Started using [:] to differentiate when and where something is a moving array as opposed to a single variable 

    Bug where computer says inputfile is not in folder (???)
      Fixed it. VScode changed directories (for some reason)
        Update?

    The dimensions for F(old) do not play well with the newer arrays. Commenting out until later
      I fixed the bug, then I found an old note (1/1/19) where I noted how to do that exact thing.

    twopih and the components to make it are never changed. Why is it calculated multiple times?
      Moved to main 

    ampfinal seems like it's always either immediately used to change the value of ampinitial, or it could be excluded by being clever
      Putting a pin in this

    ***New favorite bug: A chunk of the code not compiling was importing math as m and then using m as a variable

    We define airabsorb repeatedly despite its inputs being the same all the time. and then define m as airabsorb. Could we just use airabsorb instead?

2/25
    My main problem right now is creating an array of frequencies for each individual array. This has been easy to envision, but very dificult to create.
      I have been struck by an epiphany. What if I didn't do this part now and let the gpu handle it?

2/26
    Going to try multiplying by np.ones of the raymax so that it's separate earlier.
    I found a bunch of variables aren't orinted in the directions we want
      Haha whoops

    Changed the orientation of some of the variables. This broke my functions file. I fixed it.
      The end result is a file with nearly identical writing to the original first draft, that works for completely different reasons.

    It looks like we define timearray in the beginning then only use it in the end for one function then never touch it again.
      Can we define it inside that function instead?

    I might merge time reconstruct and receiverhitfunc
    I might not 
    It may or may not be easier to do that.

2/28
    Hello again, friend of a friend @ Blender

      Blender stuff to look up and see if we should loot those too:
        Adaptive domain - Could we avoid all geometry without a nearby ray? 

2/31
    Just for funsies: I took the size of a bunch of numbers and compared them, both between each other and to bools
      See: Size_Test.txt

3/13
    Have been having trouble with outputarray, both visualizing it and programming it.
    Since we only use it to link other arrays conveniently, I'm deciding to skip it and use the individual arrays

    We don't seem to be using all the rows for either outputarray

    I didn't make an array with the ray positions
      Haha whoops

      Did we ever change the position of temparray[:size,:,:3] in original?

      Outputarray is Receiverpoint which is an itteration of receiver positions

      temp2 takes two seconds to calculate. This sounds like a small number, but remember
        That's hundreds of times faster than entire functions, and even in our small sample
        can increase the time to about half a minute.


      Receiverhit works but is slow. Using np.pow was only slightly faster
        Scratch that. I moved a loop around and it seems faster for some reason

      After a ton of testing I've found that the function works better when you itterate through the receivers outside of the function
        Which is conveneint. Because I did that to store the receiver data separately anyway.

        One bug we have is entirely made up by us, in Fortran it checks if it's on the same receiver before it runs. In python this check is out of the loop.
          It just runs, taking up comp time 

        numpy.exp is faster than math.e for working with arrays 

        Method works and is slower than function. Time to hybridize

        After going through a few prototypes I found that one version is significantly slower, this is strange, as it's a slightly modified version of another function
          I have now decided that this is because it is operating on a larger file than the original.
            After isolating and testing I have found that this new version is faster, running at 10 seconds as opposed to its original 16

            Even further testing reveals that literally anything is better than using a function. And methods are just simpler.

      Timearray isn't used until the very-very end. It's used in TimeHeader
        only [:,:,4] is used inside function, which is timesignal


        magnitude and direction should be flattened at some point before this


3/16
    I don't know why on_hit needs 4 inputs (3 explicit and 1 implicit), but that seems like a future thing to look into.
      Things working when they shouldn't is a problem but not a problem-problem
        

3/17
    Even though in this modern day and age I've dummied out temparray, in my revision of what I've written I found that I have five separate ones in each receiver
      It was poorly programmed when I first did it. It's poorly programmed now. But I don't want to break more code so I'm going to just jury rig it

    Putting it all together. I put a lot of unnecessary nested loops in this, but it runs relatively fast otherwise

    Taking out the parts where we calculate Receiverpoint since now we already have the receiver point ready

    I've found that using multiple for loops makes it take way more time than seems necessary.

      Earlier it was running parts of the code five times more than needed and took just under 400 seconds.
      I then moved the unnecessary code out of the loop and added another loop at the end where it was necessary.
        This made the time spike to the 500 second range
      After fixing other bugs and moving functions around where posible the time has returned to 243 seconds.

      I'm uploading now before I break it again



3/18
    It seems that we define timetemparray (aka timesignal) as 0 if the first point of the respective temparray is 0.
      Else it runs the rest of the calculations

      We then define timesignal as the ifft of tempfft with length sizefft 
        It will be 0 if tempfft is 0

      Regardless of what time temparray currently is we define it as timesignal. Even if both are 0 already


    The doccumentation for fft seems to say that we may get a few glitches from using odd numbered ffts, but we can burn that bridge when we get to it

    Finished the printout.
      It runs
      Still slow but it runs

3/19

    The pressures that the receivers are getting is huge. It should at least start at 0, and it doesn't even do that. 

    I shaved 4 minutes off the runtime by moving the propagation outside of a loop. (27 mins)

    I was originally getting overflow errors starting at step 9. After moving the propagation back it moved to 46 (matches with it not taking 5x as many steps anymore)

    Ran it without the receiver data. The casting time itself is about 30 seconds. Which is still a lot, but still less than half an hour


3/21
    Broke magnitude and timesignal (accidentally)
    I think I broke the trace too (accidentally)

    Reverting to the last uploaded version, luckily that was only days ago.
      I /have/ found that the hit mechanism I'm using is messed up

    This says it doesn't hit anything at all :/

4/4
    In Fortran it will go through all nearest objects if it is close to all
    In python 3 it will only go through once depending on the order in the source code

    I know from Space Invaders that python 2 handles that better
    But it might just scrap all the code :/
        This was found to be wrong, there was just a pass inside the loop (for some reason) -4/27

4/27
    Did not have computer until just now

    Tried to sync all my versions across laptops thru git
      It was having trouble running it in the folders thru vscode
        Terminal was running from start of folder (RayTrace), instead of the open folder
        Solved by just moving the folder.
        Less organized, but mehh

    Trying to get new version running:
      Accidentally created an unholy hybrid of itterating through objects and ints that junked everything.
        I commented it out, will delete it later. I need to examine it to see what exactly happned 
        Just getting through what I can now 

4/29
    Both versions have bugs
    what I'm calling version X has a bug where it only checks specific steps of specific rays
    What I'm calling version Y has many bugs because it's an older version

    It seems to not be itterating over steps correctly, I'm going to check older editions 

    I have gotten them both to "work" individually. I'm saving my progress now. I'll sew them together later

5/2
    Ray was being held by receiver on hit. 
      Suspect this to be caused by veci never chnaging.
      I noticed that veci is usually altered by adding the product of dx and F 
      Found that neither changes after hit (@607)
        Surprised to find that it's supposed to do that exactly

        Fortran keeps the values the same, but has veci speeding away after a hit 
        Python keeps the values the same and thus makes veci slow to a crawl in leaving, registering more hits 

      Hotfix: I made it change in relation to H instead of dx so it would be far enough to keep going
        The new veci values are not exactly the same, but they're close enough that I can move on

    I seem to have also solved a glitch where the outputfile was messing up one receiver
      Old:
      	93.442821	28.839718	0.151000	0.000000
      	93.442821	28.839718	0.151000	0.000000
	      64.583200	28.599800	7.942300	0.000000
	      -2.407930	31.500340	0.151000	0.000000
	      75.110050	28.494579	0.151000	0.000000
      New:
      	93.442821	28.839718	0.151000	0.000000
	      64.583200	28.599800	0.151000	0.000000
	      64.583200	28.599800	7.942300	0.000000
	      -2.407930	31.500340	0.151000	0.000000
	      75.110050	28.494579	0.151000	0.000000
      Expected: 
      93.4428213 28.8397178 0.151
      64.5832    28.5998    0.151
      64.5832    28.5998    7.9423
      -2.40793   31.5003401 0.151
      75.11005   28.4945787 0.151

    I either just broke my receiver hit function or copied it from the wrong version, because all the values are zero
      Copied it wrong, I don't even call the new version 

    In Fortran temparray has space for 18k numbers but only uses half of it
      Scratch that. it says sizefft/2 and I missed the two 

    It now registers hits, but the magnitudes don't seem to be adding in right
      Seemingly the last big bug

    It seems we were checking the receiver hit twice. When I removed only one of these checks the ray bounced normally from the receiver again

5/7
    Ray is registering as hitting receiver 5 but has the coordinates of hitting receiver 3
        This is because it calculates R as each object in the list, then after that loop it targets R, which will logically be the last receiver in the list not matter what.

    Looking at geometry parser
    I'm not sleeping so it's hard to understand. I'm just reverse engineering it

      Does the vertex list double the number of points but not use the latter half?

      I checked how it's using the faces. It makes six faces, we need five.
        I deleted one face. It printed six.
        I deleted all faces. It printed six.
        Is it creating its own faces independently of the obj file?


5/12
    Finals week, taking things slow. 
      Examining exactly /what/ things /are/
        veci is not the boom array, but a copy of the boomarray that we are working with for the specified ray (good)


    Looking at two things today: global variables and memory locations
        Global variables would let me cut down on inputs for functions. The increased readability will make this even easier to maintain if done right
        Memory locations will let me target what I want where ever I want.
          specifically being used to get rid of receiver bug. It's a nasty bug that I haven't gotten rid of yet

    
    Looking at this code after I've had a good night's sleep:
      I think the bug is just that a chunk of code is tabbed wrong. I'll see how that goes 
        It recognizes which ray hits which receiver (again), but it only recognizes if I'm testing at ray 606. It seems to skip otherwise

    Imported a small part of Will's env function. Since it reliably hits the building now I want to verify his module by seeing 
    if the rays would interact with his box in the same way. 
      The positions work, I will check the interaction later

5/14
    F was the same object as Finitial. Causing it to only ever point up
      Changed that and now it runs separately

    Using spacing 0.35 for a good spacing size and speed  (For context on how fast it's running now)

    Updated some functions that could of ran better with constants.
      It seems to be running faster but I haven't checked that.

    Removed old comments that refered to things we no longer use/care about

    Removed timereconstruct in main file, as it exists in another file and we don't even use it in main

    Tempreceiver is only used when checking the nearest array, but I'm keeping it there as a placeholder for now

    Temparray seems to be completely dummied out, it also looks as if it's running alongside on_Hit, which does the same goal.
      The only reason I can think to keep temparray is for double hits, and I think using objects may have eliminated the need for that

5/15
    Double functionality seems to have been neglected. We shouldn't be getting those errors with these parameters, but that's a different problem entirely 

    The error from this morning has disappeared, but doubehit functionality seems to
      just be a placeholder for now. I stacked two receivers to see what their reading
      would be and only one was actually even registered

    I'll come back to it. I'll start radiosity now

    Looking at the filesizes on disk: Python's filesize (217kb), including the scraps, 
      is smaller than Fortran's executable at (252kb)
      Even accounting for space on disk, python still only takes up (236kb)

    New file runtime with same parameters (1825 rays):
      Python:   44.030 seconds
      Fortran:  54.359 seconds


    Python runs faster than Fortran now. Accuracy is off. Python only registers a hit on receiver 2 with pressure -5.450707
    Fortran registers a hit only on receiver 2 with pressure -2.23565674     

    outputsignal seems to be shifted slightly phase and amplitude are affected because
      they are based on them

      python signal starts with 0
      fortran signal ends with 0

5/16
    Made a file to create a receiver cluster from a geometry file 

    Examining geometry interaction:
      It seems like Box is too contextual to use here so I looked at the Polygon function.
      (Which says it is unfinished)
      In the original we used one for box, triangle and squares respectively.
      Here everything is triangles. so Polygon makes the most sense for that.
        I don't know what some of these inputs are becuase they're undefined in the main file.
        I'll just see what happens.

5/20
    Finished the 1:1 translation of Polygon.
      I know better than to say that it's done. It's just a translation. 
    
    Since that's ready, I can start my actual triangle function
      size here seems to be amount of vertices
      Since that's automatically 3 I can take out that input
      Now I know the concrete dimensions of G 

      Question about maximum, what if two values are the same?
      Building points seems to be equivalent to vertices, which are just called v in obj format
        If not I'll change it, but for now I'll call it v to make the line short enough to read

5/21
    Tried separating the main ray trace file into smaller modules.
      Ran into the problem of using all the variables initialized at different places in the code.
      Also ran into the problem of breaking variables and function. 
        Some needed to be obtained through other modules afterwords
        It's just a matryoshka doll of glitches. I just put it in a wip folder (work in progress)

      Did a slightly thorough look at Radiosity. It seems to be intertwined with Trace, so that'll be
        a problem to separate
    
    I noticed that the old fft file we used for Fortran was written in C. Is there a way to use that here instead
      of examining the small differences of how numpy does it? 

    Tempalpha definitely needs to be redone. It works fine with these parameters, but it looks like it'll be a problem when we upscale it

    Blender has a new update, 2.80
      The key bindings and the layout have changed. It's still written in python from what I can tell, so if we wanted we may be able to use some of its functionality
      (we probably won't but it's an option)

    Examining why fft is off. It seems in the original we used a real to complex absorption. In our newer version we were only doing discrete.
    This seems to work.

    Outputsignal now has the same values in both versions. The final pressure is still low.

    frequencias were still staggered. I staggered them the other way. This is the final stretch. All annoying bugs will be brute forced

    For reference: 
        #outputarray[:,0] = frecuencias  [:,0]
        #outputarray[:,1] = receiverpoint[0]
        #outputarray[:,2] = receiverpoint[1]
        #outputarray[:,3] = receiverpoint[2]
        #outputarray[:,4] = ampinitial   [:] / 2.0
        #outputarray[:,5] = phaseinitial [:]
        #temparray[D,:,3]=inputarray[W,0]    #initial pressures
        #temparray[D,:,4]=0.0                #magnitude
        #temparray[D,:,5]=0.0                #direction
        #timetemparray[D,:,0]=temparray[D,0,0]
        #timetemparray[D,:,1]=temparray[D,0,1]
        #timetemparray[D,:,2]=temparray[D,0,2]
        #        timetemparray[D,W,3]=timearray[W]   #Not actually used until outside function
        #        timetemparray[D,W,4]=0.0    #timesignal

      After more pruning of comments and code, we have 397 lines in the file

    Ray frequencies are consistent in air, but change after a ground hit.
      alphaground was offset. Even after changing bounds the values are still innacurate

5/22
    Alphaground is 0.009999978 in fortran, 0.01 in python. That sounds like a rounding error, but python should have more accuracy.
      I found it is more accurate. The value is 0.01 in both, but Fortran is unable to express that, hence. 
      So then what is the real problem?

      The problem was found to be in the way I was updating the frequencies.
        Ironically the masks I was using were accurate and everything else was what was
        bugged

        I finally have it working and accurate, once. It is exactly precice once. 
        Then the phase diverges wildly where the mask does not cover


5/24
    I'll come back to the last thing, just messing with the file frinting now

    fixed phase. I was saving the wrong one in the hit function.

    Amplitude has the wrong reading for alphabuilding
    The alphabuilding values are incorrect

    found old bug from when we were first writing this.
    phase and amp seem to match now


    Checking right at the end:
      Magnitude starts good, then ends bigger than it should
      Direction is perfect all through

      Timesignal is based on the others, so I can't check it yet


      Amplitude is in fact not correct at the end

5/25
    Amplitude has corrected. was supposed to use - airabsorb
    Amplitude is now accurate

    Equivalences were checked. The code now does not diverge until the inverse real fft taken during the time reconstruct


5/28
    Experimenting with caches
      It stores updates from no hit, but crashes when it hits a surface.
      This is not a pun

      Remember to ask Dr Riegel about making our own LRU, since I don't think python's native one is useful here
      and all the relevant info seems to be abstracted away.

5/31
    It's midnight so I'm not sure how to date this. It is 2:02 AM Friday May 31,2019, if I need to be super specific.
    Made a parser/sorter.
      I sorted the receivers by position as a test, since they're the most easily accessible geometry for me. 

      Arrays were difficult to sort, and we use lists in the geometry file anyway, so I tested on lists.

      I used lambda functions to read the receiver file because they're just shorter to write. 

      The sort functionality has no output, it sorts the list in memory, as opposed to outputing a copy. So be careful with this.

      I also learned how to output slices of a list that meet specific conditions
      >>>[(x,y,z) for (x,y,z) in grid if (x<100)]

      I can successfully sort a list and take the relevant values 

      Wrote up some pseudocode, since it sounds like what Will's doing

6/2/19
    Can we replace boomarray with a generator?

    Generators let us use less memory and time. One bottleneck I can think of now is the boomarray size. 
    I'll work on making that more readable and then convert it to a generator

    I tested the timing on generators and it's anywhere from seven, to hundreds of times faster.

    The generator is running slower in this prototype

    I renamed the raymax range to whoosh and the fuction runs competatively now
      (for some reason)
      It's still not as good as it could, the average for generators has been observed
       to be 10x faster

    for ray in range(raymax):
        veci = next(direction)
    for ray in range(raymax):
        ray = direction
    
    The bug was found. Using a third party variable makes the code more readable, but slows
    it down on the order of hundreds of times. The initializer can now 
    begin 1845747780 rays in just 389.3 seconds, the old method would run into memory problems
    The 1825 ray size was too fast to measure.

    or veci in direction:
    #print(veci)

    Is the correct version. The last thing was gibberish
      
    Things to look over on Tuesday:
      My parser
      Caching ray data
      Ray generator

6/4/19
      Met and introduced new interns to code.

      Examined memory usage in current code
      The new method keeps the memory usage down. There is almost no change in memory no matter how many rays are used. 
      Using boomarray does increase memory with rays and at spacing of 0.035 the program is using 60mb

      Plan of action (Short Term)
        
        Branch 1
          i) Generators
            Use generators to shorten the time needed to run calculations and reduce memory needed.
            Currently uses less memory but takes more time to do calculations, this is a bug that can be fixed.
              Also of note: when prototyping this I found that generators are able to have more points used than our current methods

          ii) Cache 
            Cache ray data so that when the dx,alpha, and diffusion are going to be used in frequency calculations
              they can instead be accessed to avoid needing to calculate again.
            This will take a significant amount of memory, to avoid bloat, this step must come after memory is saved using generators

          iii) Parallelization
            The final point in this chain. Combined both of these methods will allow for ease of parallelization, our goal from the 
              beginning

        Branch 2
          Validation
            Validate the code as it exists now.
            We have a year's worth of work. We will take what we have working now and synthesize them into one working program before 
              branching off more.
            I will compare our current results to Fortran before creating new features


      Plan of action (Long Term)
        Concepts: 
          Ray Bending / Temperature

          Inputs

          Third thing

          Radiosity

          Complex Geometry Parser (Will)

          Turbulence

6/6/19
        Looking at parallelization

        Parallelization can be done using either multiprocessing or threading.

        One method of multiprocessing is the Pool module. 
          Found that Pool does not work well for fast near instant processes. It has a startup time of around .13 seconds
          Did not find any performance gains until over 10000 processes run at minimum

          Program will freeze if code body is not nested in an main conditional

          Tested Pools with generator, it doesn't seem to be able to interact with
            generators, and also seems to run slower than what I've already been doing.

        
        Got a veci generator working with the time and memory benefits
          The timing runs the way the way initially guessed
          Now to work on the readability 

        "For ray in boom carpet" is worded pretty well
        At first it broke the program because we use D to iterate thru the alphas, but I just recalculated D 

          I don't see the 100x increase in comp time, that may be because there's other processes running and it's negligible
            compared to them, but the memory is down a lot. 
            Uses less than 32 MB when tested using mem_profile module

        Added a note about what I'm planning to use the Receiver geometry module for

        Learned how to import with namespace
          I'll see what doors this opens later

          from [module] import *


************
Trying really hard to graduate in this span of time, not much progress
************


@ R0ml
7/9/19

    Q: The speed we've gained is from using numpy which works by running parallel versions of the code written in C.
        Parallelization isn't directly possible in python according to the documentation, how can we write functions 
        for similar performance to what we have?

    Q: Is there a way to store intermediary data to avoid having to redo a process between runs (eg. Initialize geometry and tracing)

    Q: How can we /efficiently/ implement a Least Recently Used Cache that incorporates thousands of datapoints per ray per step?

      
7/9/19
    Finally added graphing

7/10/19
    Finally made graphing fast and generalized it to work outside of these tests
    Added option to name graphs in parameterfile

7/14/19
    Ran python and Fortran side by side and python finished in 9 minutes and 50 seconds, python got up to 10 minutes 15 seconds and then crashed. 
    Spacing used was 0.35 

    Made a redux of the old matlab code. It works on my computer again. I'll port these graphs to python

7/23/2019
    the.r0ml@gmail.com

7/23/2019 - But a different branch
    asked about making cache from sql

    examining Will's code

7/24/19
	      Two main bugs found:
	      	1.It doesn't register all faces
	      	2.If it does register a face it won't move

	      Undid part of code where Will chops list in half

7/26/19

      Found bug in Will's Environemnt file.
        third edge test used a different vertice and that may not have been correct
          ( I don't know. I don't have the book he read from )
