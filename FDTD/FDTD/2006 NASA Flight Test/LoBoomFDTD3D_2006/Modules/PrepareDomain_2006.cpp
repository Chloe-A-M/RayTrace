/*******************************************************************************
 *
 *  PrepareDomain_2006.cpp
 *  
 *  written by:     Sang Ik Cho
 *                  stc142@psu.edu 
 *  last modified:  4 / 30 / 2012
 * 
 *    This program generates the simulation parameter and geometry input files 
 *  necessary for LoBoomFDTD3D_MultiBldg program simulating the house and garage
 *  from 2006 NASA Flight Test.  The computational domain grid including the
 *  building structures is  defined, where the location coordinates of the 
 *  building corners and mics, calculated with the GPS survey information stored
 *  in In_coordinates.txt, are used to identify the interior and exterior points
 *  and also the boundary points.
 *  
 *  *** This program is written for the 2006 test house geometry ***
 *     
 *  *** Note that "In_coordinates.txt" for 2006 field test, is generated by 
 *      "GeoMicCoord_2006House.m" and contains the coordinate data that's 
 *      already compensated for boom azimuth. ***  
 *           
 *******************************************************************************/

#include "Headers.h"

// Definition of Custom Variable Types
struct Point
{
  double x,y,z;
};
struct Plane
{
  double a,b,c,d,D;
};
typedef vector<vector<double> > Matrix2D;

// Function Prototypes
double Determinant(double Mat[3][3]);

void PrepareDomain(Grid3D &U)
{
  int i, j, k;
  
  /*****************************************************************************
   *  Coordinate Rotating & Shifting
   *****************************************************************************/
  cout << "Rotating & Shifting coordinates... ";  
  
  // Original coordinates of buildings and microphones
  int tot_num_pt = 42;    // Total number of coordinate points stored in In_coordinates_xy.txt
  ifstream f_coord("In_coordinates_xy.txt");
  if (!f_coord) {
    cout << "ERROR: Could not open In_coordinates_xy.txt" <<endl;
    exit(1);
  }
  
  Matrix2D Coord_shift(tot_num_pt,vector<double>(3));
  vector<double> Coord_x(tot_num_pt), Coord_y(tot_num_pt), Coord_z(tot_num_pt);  

  for (i=0; i<tot_num_pt; i++) {
    f_coord >> Coord_x[i];
    f_coord >> Coord_y[i];
    f_coord >> Coord_z[i];
  }

  // Shift to accommodate extra_dim_x,y around the building geometry
  double x_shift = -*min_element(Coord_x.begin(),Coord_x.begin()+18)+extra_dim_x;
  double y_shift = -*min_element(Coord_y.begin(),Coord_y.begin()+18)+extra_dim_y;
  
  for (i=0; i<tot_num_pt; i++) {
    Coord_shift[i][0] = Coord_x[i]+x_shift;  // The smallest x-coord of the building corners is set at extra_dim_x
    Coord_shift[i][1] = Coord_y[i]+y_shift;  // The smallest y-coord of the building corners is set at extra_dim_y
    Coord_shift[i][2] = Coord_z[i];
  }
  
  Matrix2D Garage(Coord_shift.begin(),Coord_shift.begin()+8);      // Coordinates for Garage
  Matrix2D House(Coord_shift.begin()+8,Coord_shift.begin()+18);   // Coordinates for House
  Matrix2D Mics(Coord_shift.begin()+18,Coord_shift.begin()+42);   // Coordinates for Mics
  
  cout << "DONE" << endl;

  
  /*****************************************************************************
   *  Defining Planes
   *****************************************************************************/  
  cout << "Defining planes... ";
    
  Point pt[18];
  Plane P[11];
  // Define the location of the building corner points
  pt[0].x = Garage[0][0];
  pt[0].y = Garage[0][1];
  pt[0].z = Garage[0][2];
  pt[1].x = Garage[1][0];
  pt[1].y = Garage[1][1];
  pt[1].z = Garage[1][2];
  pt[2].x = Garage[2][0];
  pt[2].y = Garage[2][1];
  pt[2].z = Garage[2][2];
  pt[3].x = Garage[3][0];
  pt[3].y = Garage[3][1];
  pt[3].z = Garage[3][2];
  pt[4].x = Garage[4][0];
  pt[4].y = Garage[4][1];
  pt[4].z = Garage[4][2];
  pt[5].x = Garage[5][0];
  pt[5].y = Garage[5][1];
  pt[5].z = Garage[5][2];
  pt[6].x = Garage[6][0];
  pt[6].y = Garage[6][1];
  pt[6].z = Garage[6][2];
  pt[7].x = Garage[7][0];
  pt[7].y = Garage[7][1];
  pt[7].z = Garage[7][2];
  pt[8].x = House[0][0];
  pt[8].y = House[0][1];
  pt[8].z = House[0][2];
  pt[9].x = House[1][0];
  pt[9].y = House[1][1];
  pt[9].z = House[1][2];
  pt[10].x = House[2][0];
  pt[10].y = House[2][1];
  pt[10].z = House[2][2];
  pt[11].x = House[3][0];
  pt[11].y = House[3][1];
  pt[11].z = House[3][2];
  pt[12].x = House[4][0];
  pt[12].y = House[4][1];
  pt[12].z = House[4][2];
  pt[13].x = House[5][0];
  pt[13].y = House[5][1];
  pt[13].z = House[5][2];
  pt[14].x = House[6][0];
  pt[14].y = House[6][1];
  pt[14].z = House[6][2];
  pt[15].x = House[7][0];
  pt[15].y = House[7][1];
  pt[15].z = House[7][2];
  pt[16].x = House[8][0];
  pt[16].y = House[8][1];
  pt[16].z = House[8][2];
  pt[17].x = House[9][0];
  pt[17].y = House[9][1];
  pt[17].z = House[9][2];
  
  // Define the plane equation coefficient using the location of three corner points that lie on that respective plane
  double Mat0[3][3] = {{pt[0].x, pt[0].y, pt[0].z}, {pt[3].x, pt[3].y, pt[3].z}, {pt[4].x, pt[4].y, pt[4].z}};
  double Mat0a[3][3] = {{1, pt[0].y, pt[0].z}, {1, pt[3].y, pt[3].z}, {1, pt[4].y, pt[4].z}};
  double Mat0b[3][3] = {{pt[0].x, 1, pt[0].z}, {pt[3].x, 1, pt[3].z}, {pt[4].x, 1, pt[4].z}};
  double Mat0c[3][3] = {{pt[0].x, pt[0].y, 1}, {pt[3].x, pt[3].y, 1}, {pt[4].x, pt[4].y, 1}};
  P[0].D = Determinant(Mat0);
  P[0].d = 1;
  P[0].a = -P[0].d/P[0].D*Determinant(Mat0a);
  P[0].b = -P[0].d/P[0].D*Determinant(Mat0b);
  P[0].c = -P[0].d/P[0].D*Determinant(Mat0c);
  
  double Mat1[3][3] = {{pt[0].x, pt[0].y, pt[0].z}, {pt[4].x, pt[4].y, pt[4].z}, {pt[5].x, pt[5].y, pt[5].z}};
  double Mat1a[3][3] = {{1, pt[0].y, pt[0].z}, {1, pt[4].y, pt[4].z}, {1, pt[5].y, pt[5].z}};
  double Mat1b[3][3] = {{pt[0].x, 1, pt[0].z}, {pt[4].x, 1, pt[4].z}, {pt[5].x, 1, pt[5].z}};
  double Mat1c[3][3] = {{pt[0].x, pt[0].y, 1}, {pt[4].x, pt[4].y, 1}, {pt[5].x, pt[5].y, 1}};
  P[1].D = Determinant(Mat1);
  P[1].d = 1;
  P[1].a = -P[1].d/P[1].D*Determinant(Mat1a);
  P[1].b = -P[1].d/P[1].D*Determinant(Mat1b);
  P[1].c = -P[1].d/P[1].D*Determinant(Mat1c);
  
  double Mat2[3][3] = {{pt[1].x, pt[1].y, pt[1].z}, {pt[2].x, pt[2].y, pt[2].z}, {pt[5].x, pt[5].y, pt[5].z}};
  double Mat2a[3][3] = {{1, pt[1].y, pt[1].z}, {1, pt[2].y, pt[2].z}, {1, pt[5].y, pt[5].z}};
  double Mat2b[3][3] = {{pt[1].x, 1, pt[1].z}, {pt[2].x, 1, pt[2].z}, {pt[5].x, 1, pt[5].z}};
  double Mat2c[3][3] = {{pt[1].x, pt[1].y, 1}, {pt[2].x, pt[2].y, 1}, {pt[5].x, pt[5].y, 1}};
  P[2].D = Determinant(Mat2);
  P[2].d = 1;
  P[2].a = -P[2].d/P[2].D*Determinant(Mat2a);
  P[2].b = -P[2].d/P[2].D*Determinant(Mat2b);
  P[2].c = -P[2].d/P[2].D*Determinant(Mat2c);
  
  double Mat3[3][3] = {{pt[7].x, pt[7].y, pt[7].z}, {pt[2].x, pt[2].y, pt[2].z}, {pt[3].x, pt[3].y, pt[3].z}};
  double Mat3a[3][3] = {{1, pt[7].y, pt[7].z}, {1, pt[2].y, pt[2].z}, {1, pt[3].y, pt[3].z}};
  double Mat3b[3][3] = {{pt[7].x, 1, pt[7].z}, {pt[2].x, 1, pt[2].z}, {pt[3].x, 1, pt[3].z}};
  double Mat3c[3][3] = {{pt[7].x, pt[7].y, 1}, {pt[2].x, pt[2].y, 1}, {pt[3].x, pt[3].y, 1}};
  P[3].D = Determinant(Mat3);
  P[3].d = 1;
  P[3].a = -P[3].d/P[3].D*Determinant(Mat3a);
  P[3].b = -P[3].d/P[3].D*Determinant(Mat3b);
  P[3].c = -P[3].d/P[3].D*Determinant(Mat3c);
  
  double Mat4[3][3] = {{pt[5].x, pt[5].y, pt[5].z}, {pt[6].x, pt[6].y, pt[6].z}, {pt[4].x, pt[4].y, pt[4].z}};
  double Mat4a[3][3] = {{1, pt[5].y, pt[5].z}, {1, pt[6].y, pt[6].z}, {1, pt[4].y, pt[4].z}};
  double Mat4b[3][3] = {{pt[5].x, 1, pt[5].z}, {pt[6].x, 1, pt[6].z}, {pt[4].x, 1, pt[4].z}};
  double Mat4c[3][3] = {{pt[5].x, pt[5].y, 1}, {pt[6].x, pt[6].y, 1}, {pt[4].x, pt[4].y, 1}};
  P[4].D = Determinant(Mat4);
  P[4].d = 1;
  P[4].a = -P[4].d/P[4].D*Determinant(Mat4a);
  P[4].b = -P[4].d/P[4].D*Determinant(Mat4b);
  P[4].c = -P[4].d/P[4].D*Determinant(Mat4c);
  
  double Mat5[3][3] = {{pt[8].x, pt[8].y, pt[8].z}, {pt[11].x, pt[11].y, pt[11].z}, {pt[16].x, pt[16].y, pt[16].z}};
  double Mat5a[3][3] = {{1, pt[8].y, pt[8].z}, {1, pt[11].y, pt[11].z}, {1, pt[16].y, pt[16].z}};
  double Mat5b[3][3] = {{pt[8].x, 1, pt[8].z}, {pt[11].x, 1, pt[11].z}, {pt[16].x, 1, pt[16].z}};
  double Mat5c[3][3] = {{pt[8].x, pt[8].y, 1}, {pt[11].x, pt[11].y, 1}, {pt[16].x, pt[16].y, 1}};
  P[5].D = Determinant(Mat5);
  P[5].d = 1;
  P[5].a = -P[5].d/P[5].D*Determinant(Mat5a);
  P[5].b = -P[5].d/P[5].D*Determinant(Mat5b);
  P[5].c = -P[5].d/P[5].D*Determinant(Mat5c);
  
  double Mat6[3][3] = {{pt[8].x, pt[8].y, pt[8].z}, {pt[9].x, pt[9].y, pt[9].z}, {pt[13].x, pt[13].y, pt[13].z}};
  double Mat6a[3][3] = {{1, pt[8].y, pt[8].z}, {1, pt[9].y, pt[9].z}, {1, pt[13].y, pt[13].z}};
  double Mat6b[3][3] = {{pt[8].x, 1, pt[8].z}, {pt[9].x, 1, pt[9].z}, {pt[13].x, 1, pt[13].z}};
  double Mat6c[3][3] = {{pt[8].x, pt[8].y, 1}, {pt[9].x, pt[9].y, 1}, {pt[13].x, pt[13].y, 1}};
  P[6].D = Determinant(Mat6);
  P[6].d = 1;
  P[6].a = -P[6].d/P[6].D*Determinant(Mat6a);
  P[6].b = -P[6].d/P[6].D*Determinant(Mat6b);
  P[6].c = -P[6].d/P[6].D*Determinant(Mat6c);
  
  double Mat7[3][3] = {{pt[10].x, pt[10].y, pt[10].z}, {pt[14].x, pt[14].y, pt[14].z}, {pt[13].x, pt[13].y, pt[13].z}};
  double Mat7a[3][3] = {{1, pt[10].y, pt[10].z}, {1, pt[14].y, pt[14].z}, {1, pt[13].y, pt[13].z}};
  double Mat7b[3][3] = {{pt[10].x, 1, pt[10].z}, {pt[14].x, 1, pt[14].z}, {pt[13].x, 1, pt[13].z}};
  double Mat7c[3][3] = {{pt[10].x, pt[10].y, 1}, {pt[14].x, pt[14].y, 1}, {pt[13].x, pt[13].y, 1}};
  P[7].D = Determinant(Mat7);
  P[7].d = 1;
  P[7].a = -P[7].d/P[7].D*Determinant(Mat7a);
  P[7].b = -P[7].d/P[7].D*Determinant(Mat7b);
  P[7].c = -P[7].d/P[7].D*Determinant(Mat7c);
  
  double Mat8[3][3] = {{pt[10].x, pt[10].y, pt[10].z}, {pt[11].x, pt[11].y, pt[11].z}, {pt[14].x, pt[14].y, pt[14].z}};
  double Mat8a[3][3] = {{1, pt[10].y, pt[10].z}, {1, pt[11].y, pt[11].z}, {1, pt[14].y, pt[14].z}};
  double Mat8b[3][3] = {{pt[10].x, 1, pt[10].z}, {pt[11].x, 1, pt[11].z}, {pt[14].x, 1, pt[14].z}};
  double Mat8c[3][3] = {{pt[10].x, pt[10].y, 1}, {pt[11].x, pt[11].y, 1}, {pt[14].x, pt[14].y, 1}};
  P[8].D = Determinant(Mat8);
  P[8].d = 1;
  P[8].a = -P[8].d/P[8].D*Determinant(Mat8a);
  P[8].b = -P[8].d/P[8].D*Determinant(Mat8b);
  P[8].c = -P[8].d/P[8].D*Determinant(Mat8c);
  
  double Mat9[3][3] = {{pt[12].x, pt[12].y, pt[12].z}, {pt[17].x, pt[17].y, pt[17].z}, {pt[13].x, pt[13].y, pt[13].z}};
  double Mat9a[3][3] = {{1, pt[12].y, pt[12].z}, {1, pt[17].y, pt[17].z}, {1, pt[13].y, pt[13].z}};
  double Mat9b[3][3] = {{pt[12].x, 1, pt[12].z}, {pt[17].x, 1, pt[17].z}, {pt[13].x, 1, pt[13].z}};
  double Mat9c[3][3] = {{pt[12].x, pt[12].y, 1}, {pt[17].x, pt[17].y, 1}, {pt[13].x, pt[13].y, 1}};
  P[9].D = Determinant(Mat9);
  P[9].d = 1;
  P[9].a = -P[9].d/P[9].D*Determinant(Mat9a);
  P[9].b = -P[9].d/P[9].D*Determinant(Mat9b);
  P[9].c = -P[9].d/P[9].D*Determinant(Mat9c);
  
  double Mat10[3][3] = {{pt[15].x, pt[15].y, pt[15].z}, {pt[16].x, pt[16].y, pt[16].z}, {pt[17].x, pt[17].y, pt[17].z}};
  double Mat10a[3][3] = {{1, pt[15].y, pt[15].z}, {1, pt[16].y, pt[16].z}, {1, pt[17].y, pt[17].z}};
  double Mat10b[3][3] = {{pt[15].x, 1, pt[15].z}, {pt[16].x, 1, pt[16].z}, {pt[17].x, 1, pt[17].z}};
  double Mat10c[3][3] = {{pt[15].x, pt[15].y, 1}, {pt[16].x, pt[16].y, 1}, {pt[17].x, pt[17].y, 1}};
  P[10].D = Determinant(Mat10);
  P[10].d = 1;
  P[10].a = -P[10].d/P[10].D*Determinant(Mat10a);
  P[10].b = -P[10].d/P[10].D*Determinant(Mat10b);
  P[10].c = -P[10].d/P[10].D*Determinant(Mat10c);

  cout << "DONE" << endl;
  

  /*****************************************************************************
   *  Calculate Computational Domain
   *****************************************************************************/  
  cout << "Calculating computational domain... ";
    
  // Domain Size
  double bldg_min_x, bldg_max_x, bldg_max_y, x_intersect, boom_length_x, X_MAX, Y_MAX, Z_MAX;
  double boom_offset	= 8;	// Extra space in x_direction between boom wavefront and closest building corner, to capture the entire 
  
  vector<double> Coord_shift_col_x(18), Coord_shift_col_y(18);
  for (i=0; i<18; i++) {
    Coord_shift_col_x[i] = Coord_shift[i][0];
    Coord_shift_col_y[i] = Coord_shift[i][1];
  }  
  bldg_min_x = *min_element(Coord_shift_col_x.begin(),Coord_shift_col_x.end());  // Building corner with the largest x-coordinate value
  bldg_max_x = *max_element(Coord_shift_col_x.begin(),Coord_shift_col_x.end());  // Building corner with the largest x-coordinate value
  bldg_max_y = *max_element(Coord_shift_col_y.begin(),Coord_shift_col_y.end());  // Building corner with the largest y-coordinate value
  x_intersect = bldg_max_x+pt[14].z*tan(theta)+boom_offset;   // Initial position of the boom at the ground [m], based on boom wavefront being "boom_offset" away from the closest building corner at bldg_max_x
  i_intersect = int(ceil(x_intersect/dx))+D;      // Initial position of the boom at the ground [index]
  boom_length_x = boom_length_i/fs*c0;            // Length of the useful part of the input boom file [m], determiniing how far the domain should stretch in x & z directions.

  X_MAX = x_intersect+boom_length_x/cos(theta)+buffer_dim_x; // Domain size in x-direction [m] (excluding the PML region)
  Y_MAX = bldg_max_y+extra_dim_y;                            // Domain size in y-direction [m] (excluding the PML region)
  Z_MAX = pt[4].z+((bldg_max_x-bldg_min_x)+boom_offset+boom_length_x/cos(theta))*sin(theta)*cos(theta)+buffer_dim_z;    // Domain size in z-direction [m] (excluding the PML region)
  
  I_MAX = int(round(X_MAX/dx))+2*D;             // Domain size in x-direction [index] (including the PML region)
  J_MAX = int(round(Y_MAX/dx))+2*D;             // Domain size in y-direction [index] (including the PML region)
  K_MAX = int(round(Z_MAX/dx))+D;               // Domain size in z-direction [index] (including the PML region)

  cout << "DONE" << endl;
  
  
  /*****************************************************************************
  * Create Building Geometry
  ******************************************************************************/  
  cout << "Creating building geometry file... ";

  // Resize U according to the domain size calculated above
  U.resize(I_MAX+2);
  for (i=0; i<I_MAX+2; i++) {
    U[i].resize(J_MAX+2);
    for (j=0; j<J_MAX+2; j++) {
      U[i][j].resize(K_MAX+2);
    }
  }

  float X[I_MAX+2], Y[J_MAX+2], Z[K_MAX+2];

  for (i=1; i<I_MAX+1; i++) X[i] = (i-D)*dx;
  for (j=1; j<J_MAX+1; j++) Y[j] = (j-D)*dx;
  for (k=1; k<K_MAX+1; k++) Z[k] = (k)*dx;
  
  for (k=1; k<K_MAX+1; k++) {
    for (j=1; j<J_MAX+1; j++) {
      for (i=1; i<I_MAX+1; i++) {
        // Interior points of Garage
        if ( (P[0].a*X[i]+P[0].b*Y[j]+P[0].c*Z[k]+P[0].d)>0 && (P[1].a*X[i]+P[1].b*Y[j]+P[1].c*Z[k]+P[1].d)<0 && (P[2].a*X[i]+P[2].b*Y[j]+P[2].c*Z[k]+P[2].d)<0 && (P[3].a*X[i]+P[3].b*Y[j]+P[3].c*Z[k]+P[3].d)>0 && (P[4].a*X[i]+P[4].b*Y[j]+P[4].c*Z[k]+P[4].d)>0 )
          U[i][j][k].InOrOut = 1;
        // Interior points of House
        else if ( (P[5].a*X[i]+P[5].b*Y[j]+P[5].c*Z[k]+P[5].d)>0 && (P[6].a*X[i]+P[6].b*Y[j]+P[6].c*Z[k]+P[6].d)<0 && (P[7].a*X[i]+P[7].b*Y[j]+P[7].c*Z[k]+P[7].d)<0 && (P[8].a*X[i]+P[8].b*Y[j]+P[8].c*Z[k]+P[8].d)>0 && (P[9].a*X[i]+P[9].b*Y[j]+P[9].c*Z[k]+P[9].d)<0 && (P[10].a*X[i]+P[10].b*Y[j]+P[10].c*Z[k]+P[10].d)>0 )
          U[i][j][k].InOrOut = 1;
        // Exterior points
        else
          U[i][j][k].InOrOut = 0;
      }
    }
  }
  
  cout << "DONE" << endl;

  /*****************************************************************************
   *  Microphone selection
   *****************************************************************************/
  cout << "Reading microphone locations where pressure is to be recorded... ";
  
  ifstream f_par_mic("In_parameters_mic.txt");
  if (!f_par_mic) {
    cout << "ERROR: Could not open In_parameters_mic.txt" <<endl;
    exit(1);
  }
  Mic mic_temp;
  string line;
  while (f_par_mic.good()) {
    getline (f_par_mic,line);
    if (line=="179") {
      mic_temp.i = int(round(Mics[0][0]/dx))+D;
      mic_temp.j = int(round(Mics[0][1]/dx))+D;
      mic_temp.k = int(ceil(Mics[0][2]/dx));
      mics.push_back(mic_temp);
    }
    else if (line=="180") {
      mic_temp.i = int(round(Mics[1][0]/dx))+D;
      mic_temp.j = int(round(Mics[1][1]/dx))+D;
      mic_temp.k = int(ceil(Mics[1][2]/dx));
      mics.push_back(mic_temp);
    }
    else if (line=="181") {
      mic_temp.i = int(round(Mics[2][0]/dx))+D;
      mic_temp.j = int(round(Mics[2][1]/dx))+D;
      mic_temp.k = int(ceil(Mics[2][2]/dx));
      mics.push_back(mic_temp);
    }
    else if (line=="182") {
      mic_temp.i = int(round(Mics[3][0]/dx))+D;
      mic_temp.j = int(round(Mics[3][1]/dx))+D;
      mic_temp.k = int(ceil(Mics[3][2]/dx));
      mics.push_back(mic_temp);
    }
    else if (line=="183") {
      mic_temp.i = int(round(Mics[4][0]/dx))+D;
      mic_temp.j = int(round(Mics[4][1]/dx))+D;
      mic_temp.k = int(round(Mics[4][2]/dx));
      mics.push_back(mic_temp);
    }
    else if (line=="184") {
      mic_temp.i = int(floor(Mics[5][0]/dx))+D;
      mic_temp.j = int(round(Mics[5][1]/dx))+D;
      mic_temp.k = int(round(Mics[5][2]/dx));
      mics.push_back(mic_temp);
    }
    else if (line=="185") {
      mic_temp.i = int(round(Mics[6][0]/dx))+D;
      mic_temp.j = int(round(Mics[6][1]/dx))+D;
      mic_temp.k = int(round(Mics[6][2]/dx));
      mics.push_back(mic_temp);
    }
    else if (line=="186") {
      mic_temp.i = int(round(Mics[7][0]/dx))+D;
      mic_temp.j = int(round(Mics[7][1]/dx))+D;
      mic_temp.k = 1;
      mics.push_back(mic_temp);
    }
    else if (line=="187") {
      mic_temp.i = int(round(Mics[8][0]/dx))+D;
      mic_temp.j = int(round(Mics[8][1]/dx))+D;
      mic_temp.k = 1;
      mics.push_back(mic_temp);
    }
    else if (line=="188") {
      mic_temp.i = int(round(Mics[9][0]/dx))+D;
      mic_temp.j = int(round(Mics[9][1]/dx))+D;
      mic_temp.k = int(round(Mics[9][2]/dx));
      mics.push_back(mic_temp);
    }
    else if (line=="189") {
      mic_temp.i = int(round(Mics[10][0]/dx))+D;
      mic_temp.j = int(round(Mics[10][1]/dx))+D;
      mic_temp.k = int(round(Mics[10][2]/dx));
      mics.push_back(mic_temp);
    }
    else if (line=="191") {
      mic_temp.i = int(round(Mics[11][0]/dx))+D;
      mic_temp.j = int(round(Mics[11][1]/dx))+D;
      mic_temp.k = 1;
      mics.push_back(mic_temp);
    }
    else if (line=="192") {
      mic_temp.i = int(round(Mics[12][0]/dx))+D;
      mic_temp.j = int(round(Mics[12][1]/dx))+D;
      mic_temp.k = 1;
      mics.push_back(mic_temp);
    }
    else if (line=="193") {
      mic_temp.i = int(round(Mics[13][0]/dx))+D;
      mic_temp.j = int(round(Mics[13][1]/dx))+D;
      mic_temp.k = int(round(Mics[13][2]/dx));
      mics.push_back(mic_temp);
    }
    else if (line=="194") {
      mic_temp.i = int(round(Mics[14][0]/dx))+D;
      mic_temp.j = int(round(Mics[14][1]/dx))+D;
      mic_temp.k = 1;
      mics.push_back(mic_temp);
    }
    else if (line=="195") {
      mic_temp.i = int(round(Mics[15][0]/dx))+D;
      mic_temp.j = int(round(Mics[15][1]/dx))+D;
      mic_temp.k = int(round(Mics[15][2]/dx));
      mics.push_back(mic_temp);
    }
    else if (line=="196") {
      mic_temp.i = int(ceil(Mics[16][0]/dx))+D;
      mic_temp.j = int(round(Mics[16][1]/dx))+D;
      mic_temp.k = 1;
      mics.push_back(mic_temp);
    }
    else if (line=="197") {
      mic_temp.i = int(ceil(Mics[17][0]/dx))+D;
      mic_temp.j = int(round(Mics[17][1]/dx))+D;
      mic_temp.k = int(round(Mics[17][2]/dx));
      mics.push_back(mic_temp);
    }
    else if (line=="198") {
      mic_temp.i = int(floor(Mics[18][0]/dx))+D;
      mic_temp.j = int(round(Mics[18][1]/dx))+D;
      mic_temp.k = 1;
      mics.push_back(mic_temp);
    }
    else if (line=="199") {
      mic_temp.i = int(round(Mics[19][0]/dx))+D;
      mic_temp.j = int(round(Mics[19][1]/dx))+D;
      mic_temp.k = 1;
      mics.push_back(mic_temp);
    }
    else if (line=="200") {
      mic_temp.i = int(round(Mics[20][0]/dx))+D;
      mic_temp.j = int(round(Mics[20][1]/dx))+D;
      mic_temp.k = int(round(Mics[20][2]/dx));
      mics.push_back(mic_temp);
    }
    else if (line=="202") {
      mic_temp.i = int(round(Mics[21][0]/dx))+D;
      mic_temp.j = int(round(Mics[21][1]/dx))+D;
      mic_temp.k = int(round(Mics[21][2]/dx));
      mics.push_back(mic_temp);
    }
    else if (line=="207") {
      mic_temp.i = int(round(Mics[22][0]/dx))+D;
      mic_temp.j = int(floor(Mics[22][1]/dx))+D;
      mic_temp.k = int(round(Mics[22][2]/dx));
      mics.push_back(mic_temp);
    }
    else if (line=="288") {
      mic_temp.i = int(ceil(Mics[23][0]/dx))+D;
      mic_temp.j = int(floor(Mics[23][1]/dx))+D;
      mic_temp.k = int(round(Mics[23][2]/dx));
      mics.push_back(mic_temp);
    }
  }
  f_par_mic.close();
  num_mics = mics.size();   // Total number of microphones recording
  
  cout << "DONE" << endl;

  
  /*****************************************************************************
   *  Domain & Microphone Parameters
   *****************************************************************************/
  // Display the domain size 
  long long TotalNumPt = (long long)I_MAX*(long long)J_MAX*(long long)K_MAX;
  cout << endl;
  cout << "\t Size of the domain (X_MAX, Y_MAX, Z_MAX) = (" << (I_MAX-2*D)*dx << ", " << (J_MAX-2*D)*dx << ", " << (K_MAX-D)*dx << ")" << endl;
  cout << "\t Size of the domain (I_MAX, J_MAX, K_MAX) = (" << I_MAX << ", " << J_MAX << ", " << K_MAX << ")" << endl;
  cout << "\t Total number of grid points = " << TotalNumPt << endl;
  if (boom_length_i > input_length_i)
    cout << "WARNING: boom_length > input_length" << endl; 
  
  return;
}

double Determinant(double Mat[3][3])
{
  return Mat[0][0]*Mat[1][1]*Mat[2][2]+Mat[0][1]*Mat[1][2]*Mat[2][0]+Mat[0][2]*Mat[1][0]*Mat[2][1]-Mat[0][0]*Mat[1][2]*Mat[2][1]-Mat[0][1]*Mat[1][0]*Mat[2][2]-Mat[0][2]*Mat[1][1]*Mat[2][0];
}